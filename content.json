{"meta":{"title":"BLOG","subtitle":null,"description":null,"author":"zhangxiaopei","url":"https://zhangxiaopei.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-06-07T02:53:47.542Z","updated":"2020-06-07T02:53:47.542Z","comments":false,"path":"about/index.html","permalink":"https://zhangxiaopei.github.io/about/index.html","excerpt":"","text":"本博客主要记录本人在工作生活中学习以及遇到问题的记录，基本都是本人实际操作过的。主要目的有: 记录工作生活中自己的所学、所想、所做 防止以后忘记了又得重新查资料踩坑 给走过路过的兄弟姐妹们一起学习、快速解决问题"},{"title":"分类","date":"2020-05-10T05:24:11.629Z","updated":"2020-05-10T05:24:11.629Z","comments":false,"path":"categories/index.html","permalink":"https://zhangxiaopei.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Flutter入门01_第一个Flutter项目","slug":"Flutter入门01_第一个Flutter项目","date":"2020-05-24T03:05:45.000Z","updated":"2020-05-24T15:35:04.098Z","comments":true,"path":"2020/05/24/Flutter入门01_第一个Flutter项目/","link":"","permalink":"https://zhangxiaopei.github.io/2020/05/24/Flutter入门01_第一个Flutter项目/","excerpt":"","text":"目录 Flutter SDK下载 环境变量配置 检查开发环境 创建flutter项目 修改flutter项目权限 Xcode打开Flutter项目 使用VSCode开发Flutter 1. Flutter SDK下载Flutter下载地址: Flutter SDK releases - Flutter 2. 环境变量配置 编辑.bash_profile文件（如果是安装zsh，需编辑.zshrc文件） 12vim ~/.bash_profile //terminalvim ~/.zshrc //zsh 将Flutter路径的bin目录以及Flutter国内镜像配置到环境变量里面 123export PATH=&quot;/Users/zhangpeizeng/flutter/bin:$PATH&quot;export PUB_HOSTED_URL=&quot;https://pub.flutter-io.cn&quot;export FLUTTER_STORAGE_BASE_URL=&quot;https://storage.flutter-io.cn&quot; 重新执行.bash_profile文件 1source ~/.bash_profile 检查环境变量是否配置正确 1flutter -h 如果有出现帮助信息，即代表环境变量配置ok 3. 检查开发环境 执行flutter doctor会检查iOS和安卓开发环境的都配置情况 根据提示执行指定命令 例如图中提示执行sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer 执行后再通过flutter doctor检查 4. 创建flutter项目1sudo flutter create flutterdemo 注意项目名不能有大写字母，会报错 5. 修改flutter项目权限 6. Xcode打开Flutter项目双击Runner.xcodeproj，然后运行 如果没有正确修改权限的话，会报错 7. 使用VSCode开发Flutter 安装插件：Dart、Flutter和Awesome Flutter Snippets 将 flutterdemo 拖进 VSCode，然后右下角选择模拟器，然后在 TERMINAL 中执行 flutter run，即可运行 flutter项目","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://zhangxiaopei.github.io/categories/Flutter/"}],"tags":[]},{"title":"私有Pod库","slug":"私有Pod库","date":"2020-05-24T01:05:45.000Z","updated":"2020-05-24T01:31:14.916Z","comments":true,"path":"2020/05/24/私有Pod库/","link":"","permalink":"https://zhangxiaopei.github.io/2020/05/24/私有Pod库/","excerpt":"","text":"私有Pod库的创建和使用方法基本和 公有Pod库 一样, 唯一不一样的地方是他们的Spec Repo不一样, 公有Pod库的 podspec 由 CocoaPods/Specs 管理, 而私有Pod库则需要自己建立一个仓库来管理 podspec. 流程可看 官网 目录 创建一个存放Spec Repo的Repositories 创建私有Spec Repo 发布Pod库 Podfile中使用 1. 创建一个存放Spec Repo的Repositories在Github或者自己的git服务器中新建一个Repositories, 用来存放和管理Spec Repo 2. 创建私有Spec Repo1pod repo add [Private Repo Name] [GitHub HTTPS clone URL] 3. 发布Pod库1pod repo push [Private Repo Name] lib.podspec 4. Podfile中使用在Podfile文件上方，添加 1source &apos;[GitHub HTTPS clone URL]&apos; 就可以使用自己的私有Pod库了","categories":[{"name":"Cocoapods","slug":"Cocoapods","permalink":"https://zhangxiaopei.github.io/categories/Cocoapods/"}],"tags":[]},{"title":"markdown语法","slug":"markdown语法","date":"2020-05-23T09:52:35.000Z","updated":"2020-05-23T14:56:21.649Z","comments":true,"path":"2020/05/23/markdown语法/","link":"","permalink":"https://zhangxiaopei.github.io/2020/05/23/markdown语法/","excerpt":"","text":"目录 标题 缩进 对齐方式 斜体、粗体、加粗斜体、删除线 链接 图片 列表 目录与跳转 多级引用 字体、字号、颜色 代码块 表格 1. 标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 &lt;!--最多6级标题--&gt; 效果： 一级标题二级标题三级标题四级标题五级标题六级标题 2. 缩进123&amp;emsp;或&amp;#8195; //全角&amp;ensp;或&amp;#8194; //半角&amp;nbsp;或&amp;#160; //半角之半角 效果： &emsp;或&#8195; //全角&ensp;或&#8194; //半角&nbsp;或&#160; //半角之半角 3. 对齐方式123&lt;center&gt;行中心对齐&lt;/center&gt;&lt;p align=&quot;left&quot;&gt;行左对齐&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;行右对齐&lt;/p&gt; 效果： 行中心对齐 行左对齐 行右对齐 4. 斜体、粗体、加粗斜体、删除线1234*斜体*或_斜体_**粗体*****加粗斜体***~~删除线~~ 效果： 斜体或斜体粗体加粗斜体删除线 5. 链接1[百度](https://www.baidu.com) 效果： 百度 6. 图片1![xxx](/xxx/xxx.png) 7. 列表1234567* 无序列表项 一+ 无序列表项 二- 无序列表项 三1. 有序列表项 一2. 有序列表项 二3. 有序列表项 三 效果： 无序列表项 一 无序列表项 二 无序列表项 三 有序列表项 一 有序列表项 二 有序列表项 三 8. 目录与跳转123456789----## 目录1. [目录1](#jump1)2. [目录2](#jump2)---### &lt;span id=&quot;jump1&quot;&gt;1. 目录1&lt;/span&gt;---### &lt;span id=&quot;jump2&quot;&gt;2. 目录2&lt;/span&gt; 9. 多级引用123&gt;&gt;&gt; 多级引用&gt;&gt; 多级引用&gt; 多级引用 效果： 多级引用 多级引用 多级引用 10. 字体、字号、颜色123456&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=12 face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;&lt;font color=gray size=5&gt;gray&lt;/font&gt;&lt;font color=#00ffff size=3&gt;null&lt;/font&gt; 效果： 我是黑体字我是微软雅黑我是华文彩云黑体graynull 11. 代码块12345`代码块`、、、代码块、、、 效果： 代码块 1代码块 12. 表格12345|列1|列2|列3||-|-|-||值1|值2|值3||值1|值2|值3||值1|值2|值3| 效果： 列1 列2 列3 值1 值2 值3 值1 值2 值3 值1 值2 值3","categories":[{"name":"博客","slug":"博客","permalink":"https://zhangxiaopei.github.io/categories/博客/"}],"tags":[]},{"title":"公有Pod库","slug":"公有Pod库","date":"2020-05-23T07:18:54.000Z","updated":"2020-05-23T09:28:32.236Z","comments":true,"path":"2020/05/23/公有Pod库/","link":"","permalink":"https://zhangxiaopei.github.io/2020/05/23/公有Pod库/","excerpt":"","text":"公有Pod库的 podspec 由 CocoaPods/Specs 管理 目录 注册CocoaPods账户信息 创建Pod库 编辑.podspec文件 验证.podspec文件的合法性 提交代码到github, 发布一个release版本 发布Pod库 更新维护podspec 常见问题 1. 注册CocoaPods账户信息创建之前需提前安装好cocoapods，这里使用 trunk 命令创建 1pod trunk register 邮箱地址 &apos;用户名&apos; --verbose 然后 cocoapods 就会上面填写的邮箱地址发送确认邮件 打开邮件中的链接即注册完成 注册完成后可以使用下面命令查看注册信息 1pod trunk me 2. 创建Pod库先在 github 创建一个名字为 XPPods 的 repositories 然后使用 pod lib create XPPods 命令，详见 Using Pod Lib Create 简单配置一下 pod库 3. 编辑.podspec文件 添加依赖 1s.dependency &apos;库名&apos; 4. 验证.podspec文件的合法性终端 cd 到 XPPods.podspec 文件所在文件夹, 执行: 1pod lib lint XPPods.podspec 将警告或者错误解决完了，就会通过校验 123-&gt; XPPods (0.1.0)XPPods passed validation. 5. 提交代码到github, 发布一个release版本 提交代码到前面创建的 XPPods repositories 1234git add .git commit -m &quot;创建 pod 库&quot;git remote add origin git@github.com:zhangxiaopei/XPPods.gitgit push -u origin master -f 打tag，推送到远程，即发布一个release版本 12git tag -a 0.1.0 -m &apos;创建 pod 库&apos;git push origin --tags 6. 发布Pod库执行： 1pod trunk push XPPods.podspec 7. 更新维护podspec 修改podspec中的版本号 打tag上传 执行 pod trunk push 8. 常见问题 [!] Unable to find a pod with name, author, summary, or description matching XPPods 原因：cocoapods中search_index文件缓存比较旧，删掉即可 1rm ~/Library/Caches/CocoaPods/search_index.json","categories":[{"name":"Cocoapods","slug":"Cocoapods","permalink":"https://zhangxiaopei.github.io/categories/Cocoapods/"}],"tags":[]},{"title":"iOS App签名的原理","slug":"iOS-App签名的原理","date":"2020-05-11T14:54:14.000Z","updated":"2020-05-11T15:16:19.697Z","comments":true,"path":"2020/05/11/iOS-App签名的原理/","link":"","permalink":"https://zhangxiaopei.github.io/2020/05/11/iOS-App签名的原理/","excerpt":"","text":"整体流程第 1 步依次点击在 “钥匙串访问” - “证书助理” - “从证书颁发机构请求证书”，按提示操作完成后，会生成一个 CertificateSigningRequest 文件， CertificateSigningRequest 文件里面包含着公钥，而私钥保存在本地电脑里。 第 2 步苹果自己有固定的一对公私钥，私钥在苹果后台，公钥在每个 iOS 设备上。 第 3 步把 CertificateSigningRequest 文件传到苹果后台生成证书，并下载到本地。安装在含有私钥的电脑上，钥匙串访问就会把证书和私钥关联起来，可在钥匙串访问导出 p12 文件。 第 4 步创建 Provisioning Profile 文件，配置证书 / AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件。 第 5 步XCode 会通过第 3 步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 _CodeSignature 目录下。 第 6 步在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证 embedded.mobileprovision 的数字签名是否正确，里面的证书签名也会再验一遍。 第 7 步确保了 embedded.mobileprovision 里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 APP 里的 Entitlements 对应等。","categories":[],"tags":[]},{"title":"symbolicatecrash解析crash文件","slug":"symbolicatecrash解析crash文件","date":"2020-05-11T14:49:03.601Z","updated":"2020-05-11T14:49:03.602Z","comments":true,"path":"2020/05/11/symbolicatecrash解析crash文件/","link":"","permalink":"https://zhangxiaopei.github.io/2020/05/11/symbolicatecrash解析crash文件/","excerpt":"","text":"导出crash文件Xcode —&gt; Window —&gt; Devices and Simulators —&gt; View Device Logs ，然后选中导出。 找到.app文件和.dsym文件 .app文件：直接解压缩.ipa文件，在Payload文件夹里面取得 .dsym文件：.xcarchive文件显示包内容，在dSYMs文件夹里面取得 找到symbolicatecrash文件在terminal输入以下命令找到symbolicatecrash文件路径 1find /Applications/Xcode.app -name symbolicatecrash -type f 然后拷贝到自己新建的文件夹 1cp /Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash ~/Desktop/crash 解析将上面所有文件放在同一个文件夹里面，然后在terminal中用cd命令进入这个文件夹，用下面命令进行解析，并输出txt文件 1./symbolicatecrash ./2018-5-1\\ 上午11-07.crash &gt;log.txt 附 Error: “DEVELOPER_DIR” is not defined at ./symbolicatecrash line 69.解决办法，在terminal中输入： 1export DEVELOPER_DIR=&quot;/Applications/Xcode.app/Contents/Developer&quot; 查看.app 文件 uuid 1dwarfdump --uuid xxx.app/xxx 查看.dsym 文件 uuid 1dwarfdump --uuid xxxx.dSYM","categories":[{"name":"开发调试","slug":"开发调试","permalink":"https://zhangxiaopei.github.io/categories/开发调试/"}],"tags":[]},{"title":"加密、数字签名与证书","slug":"加密、数字签名与证书","date":"2020-05-10T14:48:26.000Z","updated":"2020-05-11T14:58:05.968Z","comments":true,"path":"2020/05/10/加密、数字签名与证书/","link":"","permalink":"https://zhangxiaopei.github.io/2020/05/10/加密、数字签名与证书/","excerpt":"","text":"“加密”（encrypt），就是把消息用某种方式转换成谁也看不懂的乱码，只有掌握特殊“钥匙”的人才能再转换出原始文本。这里的“钥匙”就叫做“密钥”（key），加密前的消息叫“明文”（plain text/clear text），加密后的乱码叫“密文”（cipher text），使用密钥还原明文的过程叫“解密”（decrypt），是加密的反操作，加密解密的操作过程就是“加密算法”。 对称加密对称加密指加密和解密时使用的密钥都是同一个，是“对称”的。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。 对称加密算法有 RC4、DES、3DES、AES、ChaCha20 等，但前三种算法都被认为是不安全的，通常都禁止使用，目前常用的只有 AES 和 ChaCha20。 对称算法还有一个“分组模式”的概念。 分组模式：DES和AES都属于分组密码，它们只能加密固定长度的明文。如果需要加密任意长度的明文，就需要对分组密码进行迭代，而分组密码的迭代方法就称为分组密码的“模式”。 主要模式： ECB模式：Electronic Code Book mode（电子密码本模式） CBC模式：Cipher Block Chaining mode（密码分组链接模式）（推荐使用） CFB模式：Cipher FeedBack mode（密文反馈模式） OFB模式：Output FeedBack mode（输出反馈模式） CTR模式：CounTeR mode（计数器模式）（推荐使用） 拿ECB来举例子，假设使用AES128，密钥长度是16字节，那么就把明文按16字节分组，然后每个分组用密钥加密。其他的CBC、OFB等的方法类似，但细节不同，例如CBC增加了初始向量。 非对称加密对称加密有一个很大的问题：如何把密钥安全地传递给对方，术语叫“密钥交换”。所以就出现非对称加密。 非对称加密有两个密钥，一个叫“公钥”（public key），一个叫“私钥”（private key）。两个密钥是不同的，“不对称”，公钥可以公开给任何人使用，而私钥必须严格保密。 公钥和私钥有个特别的“单向”性，虽然都可以用来加密解密，但公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。 非对称加密有DH、DSA、RSA、ECC 等。其中，RSA可能是最著名的一个，几乎可以说是非对称加密的代名词，它的安全性基于“整数分解”的数学难题，使用两个超大素数的乘积作为生成密钥的材料，想要从公钥推算出私钥是非常困难的。 混合加密虽然非对称加密没有“密钥交换”的问题，但是由于非对称加密的实现都是基于复杂的数学难题，运算速度慢。所以需要结合对称加密和非对称加密，也就是混合加密。 具体流程： 在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE，首先解决密钥交换的问题。 然后用随机数产生对称算法使用的“会话密钥”（session key），再用公钥加密。因为会话密钥很短，通常只有 16 字节或 32 字节，所以慢一点也无所谓。 对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换，后续就不再使用非对称加密，全都使用对称加密。 摘要算法黑客虽然拿不到会话密钥，无法破解密文，但可以通过窃听收集到足够多的密文，再尝试着修改、重组后发给网站。因为没有完整性保证，服务器只能“照单全收”，然后他就可以通过服务器的响应获取进一步的线索，最终就会破解出明文。所以，需要实现完整性。 实现完整性的手段主要是摘要算法（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function）。 一般的摘要算法有MD5（Message-Digest 5）、SHA-1（Secure Hash Algorithm 1），它们就是最常用的两个摘要算法，能够生成 16 字节和 20 字节长度的数字摘要。但这两个算法的安全强度比较低，不够安全，在 TLS 里已经被禁止使用了。 目前 TLS 推荐使用的是 SHA-1 的后继者：SHA-2。SHA-2 实际上是一系列摘要算法的统称，总共有 6 种，常用的有 SHA224、SHA256、SHA384，分别能够生成 28 字节、32 字节、48 字节的摘要。 数字签名黑客可以伪装成网站来窃取信息。而反过来，他也可以伪装成你，向网站发送支付、转账等消息，网站没有办法确认你的身份，钱可能就这么被偷走了。所以，需要实现身份认证。 数字签名可以实现身份认证。 使用私钥再加上摘要算法，就能够实现“数字签名”，同时实现“身份认证”和“不可否认”。 数字签名的原理其实很简单，就是把公钥私钥的用法反过来，之前是公钥加密、私钥解密，现在是私钥加密、公钥解密。 比如，你用自己的私钥签名一个消息“我是小明”。网站收到后用你的公钥验签，确认身份没问题，于是也用它的私钥签名消息“我是某宝”。你收到后再用它的公钥验一下，也没问题，这样你和网站就都知道对方不是假冒的，后面就可以用混合加密进行安全通信了。 数字证书和 CA因为谁都可以发布公钥，我们还缺少防止黑客伪造公钥的手段。所以我们需要CA（Certificate Authority，证书认证机构）。由它来给各个公钥签名，用自身的信誉来保证公钥无法伪造，是可信的。 CA 对公钥的签名认证也是有格式的，包含序列号、用途、颁发者、有效时间等等，把这些打成一个包再签名，完整地证明公钥关联的各种信息，形成“数字证书”（Certificate）。 证书信任链： 客户端得到服务端返回的证书，通过读取得到 服务端证书的发布机构（Issuer） 客户端去操作系统查找这个发布机构的的证书，如果是不是根证书就继续递归下去 直到拿到根证书。 用 根证书的公钥 去 解密验证 上一层证书的合法性，再拿上一层证书的公钥去验证更上层证书的合法性；递归回溯。 最后验证服务器端的证书是 可信任 的。","categories":[{"name":"网络基础","slug":"网络基础","permalink":"https://zhangxiaopei.github.io/categories/网络基础/"}],"tags":[]},{"title":"网络相关概念","slug":"网络相关概念","date":"2020-05-10T13:41:39.000Z","updated":"2020-05-10T14:42:39.106Z","comments":true,"path":"2020/05/10/网络相关概念/","link":"","permalink":"https://zhangxiaopei.github.io/2020/05/10/网络相关概念/","excerpt":"","text":"TCP/IPTCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。 IP协议（Internet Protocol）主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。 IPv4: 地址是四个用 “.” 分隔的数字，例如“192.168.0.1”，总共有 2^32 个可以分配的地址。 IPv6: 地址用八组 “:” 分隔的数字，例如“ABCD:EF01:2345:6789:ABCD:EF01:2345:6789”，总共有 2^128 个可以分配的地址。 TCP协议（Transmission Control Protocol）位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。 DNS（域名系统，Domain Name System）域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。 顶级域名: 表示商业公司的“com”、表示教育机构的“edu”，表示国家的“cn”“uk”等域名解析: 把域名 映射到真实的 IP地址。 URI（统一资源标识符，Uniform Resource Identifier）/URL（统一资源定位符， Uniform Resource Locator）URL 实际上是 URI 的一个子集，两者差异不大，所以一般不会做严格的区分。 Tips: URI 是 Identifier，打个比方，我们能通过 URI 来找到小明，然而找到小明可以有多种方式，我们可以通过 Location 来找到小明，即：URL；也可以通过 Name 来找到小明，即：URN。URL 和 URN 都是 URI 的子集。 三个基本的部分构成： 协议名：即访问该资源应当使用的协议，例如：https 主机名：即互联网上主机的标记，可以是域名或 IP 地址，例如：zhangxiaopei.github.io 路径：即资源在主机上的位置，使用“/”分隔多级目录, 例如：2020/05/10/网络相关概念/ HTTPS全称是“HTTP over SSL/TLS”，也就是运行在 SSL/TLS 协议上的 HTTP。 SSL: Secure Socket LayerTLS: Transport Layer Security 代理（Proxy）代理的种类： 匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器； 透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端； 正向代理：靠近客户端，代表客户端向服务器发送请求； 反向代理：靠近服务器端，代表服务器响应客户端的请求； CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。 代理的应用： 负载均衡：把访问请求均匀分散到多台机器，实现访问集群化； 内容缓存：暂存上下行的数据，减轻后端的压力； 安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器； 数据处理：提供压缩、加密等额外的功能。","categories":[{"name":"网络基础","slug":"网络基础","permalink":"https://zhangxiaopei.github.io/categories/网络基础/"}],"tags":[]},{"title":"用Github+Hexo搭建个人博客","slug":"用Github-Hexo搭建个人博客","date":"2019-08-05T08:43:50.000Z","updated":"2020-05-24T03:44:25.566Z","comments":true,"path":"2019/08/05/用Github-Hexo搭建个人博客/","link":"","permalink":"https://zhangxiaopei.github.io/2019/08/05/用Github-Hexo搭建个人博客/","excerpt":"","text":"Github 新建 Repository点击“New”按钮，在Repository Name处输入“用户名.github.io”，注意此处的“用户名”必须为Github的帐号名称，例如截图中需输入“zhangxiaopei.github.io”，这是固定写法，写错的话后续访问会找不到界面（404） 环境配置 下载nvm 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash Tips： 如果这里出现443端口连接被拒 (Failed to connect to raw.githubusercontent.com port 443: Connection refused) 的情况，一般是因为墙的原因，可以配置下代理: 1export https_proxy=http://127.0.0.1:xxx http_proxy=http://127.0.0.1:xxx all_proxy=socks5://127.0.0.1:xxx 再执行下上面命令即可。 配置环境变量 123export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion 安装 node 1nvm install stable 安装 hexo 1npm install -g hexo-cli hexo的使用初始化1hexo init blogProjectName 初始化完成之后，就会在指定目录下创建一个文件夹 其中_config.yml是配置文件，source存放所有md文件，themes存放主题信息 预览1hexo s 然后就可以在浏览器输入 http://localhost:4000 预览了 Tips: 使用 hexo s -p 5000 可以指定端口为 5000 新建博客1hexo n &quot;title&quot; 当然也可以直接把已经存在md文件拖进来，然后在顶部加上以下代码，否则预览的时候旁边的导航栏会取不到title 123---title: title--- 生成静态网页1hexo g 刷新一下 http://localhost:4000 就可以看到新建的博客了 将博客地址部署到服务器修改_config.yml中deploy的配置 然后执行 1hexo d 部署成功之后，就可以输入 https://zhangxiaopei.github.io 查看自己的博客啦～～ Tips: 出现 Deployer not found: github 错误，可安装下插件 1npm install hexo-deployer-git --save Tips: 出现 TypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Object 错误，是因为node版本太高了，降低node版本就行了（我原本使用的是v14.2.0，降级为v12.14.0就ok了） 图片使用 修改_config.yml中post_asset_folder参数，改为true 安装插件 1npm install https://github.com/CodeFalling/hexo-asset-image -- save 运行 hexo n 命令生成文件的时候，就会自动创建文件夹了 在md文件中用 ![](xxx/xxx.jpg) 的方式引用，执行hexo g命令后，可在public文件夹中指定路径下的index.html文件中看到图片的路径 Tips: 图片引用使用此路径 (xxxx/图片名.jpg) 即可，不要使用绝对路径 其中的 yoursite.com 为预览图片时候访问的域名，可以在_config.yml中配置，如果是本地预览，需将url改成 http://localhost:4000，如果要部署到服务器，将url改成 https://zhangxiaopei.github.io 即可 备注： 由于hexo3版本后对很多插件支持有问题，hexo-asset-image插件在处理data.permalink链接时出现路径错误，导致index.html文件中图片的默认路径不对，可下载以下插件修复 1npm install https://github.com/7ym0n/hexo-asset-image --sa 主题官方下载地址 https://hexo.io/themes/index.html 下载后放进themes文件夹里，然后修改_config.yml文件中的theme参数即可","categories":[{"name":"博客","slug":"博客","permalink":"https://zhangxiaopei.github.io/categories/博客/"}],"tags":[]}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://zhangxiaopei.github.io/categories/Flutter/"},{"name":"Cocoapods","slug":"Cocoapods","permalink":"https://zhangxiaopei.github.io/categories/Cocoapods/"},{"name":"博客","slug":"博客","permalink":"https://zhangxiaopei.github.io/categories/博客/"},{"name":"开发调试","slug":"开发调试","permalink":"https://zhangxiaopei.github.io/categories/开发调试/"},{"name":"网络基础","slug":"网络基础","permalink":"https://zhangxiaopei.github.io/categories/网络基础/"}],"tags":[]}